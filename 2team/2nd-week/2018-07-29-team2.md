6.1 객체지향언어
===================

객체지향이론
---------------
### 실제 세계는 객체로 이루어져 있으며, 발생하는 모든 사건들은 객체 간의 상호작용이다.


- 절차지향언어 : 실행 순서를 중시
- 객체지향언어 : **객체의 속성과 기능 정의를 중시**

 객체지향프로그래밍(Object Oriented Programming)을 통해 복잡한 프로그램의 설계, 시간과 비용 절약가능

--------------------

특징
-------------------

    1. 높은 코드의 재사용성
        - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성
    2. 코드의 관리가 용이
        - 코드 간의 관계를 이용하여 쉽게 코드를 변경
    3. 신뢰성 높은 프로그래밍
        - 제어자와 메서드 통해 데이터를 보호, 중복 코드 제거로 오동작을 방지

요약하면, 객체지향언어는 **코드의 재사용성이 높고 유지보수가 용이**

6.2 객체와 클래스
=================

정의
-------
### 객체(object) : **실제로 존재하는 사물 또는 개념**으로 기능, 속성에 따라 용도 다름
### 클래스(class) : **객체를 정의해 놓은 것**으로 객체를 생성하는데 쓰임

> 프로그래밍에서 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻함

즉, 클래스와 객체는 **설계도와 이를 통해 만든 제품 간의 관계와 유사**  
이를 통해 **코드를 간결하게 작성하고 재사용성을 높임**

JDK에서는 다양한 클래스(JAVA API)를 제공하고 있으며, 이를 통해 보다 쉽게 프로그램을 작성할 수 있음

------------------------------------

객체와 인스턴스
------------
### 인스턴스(instance) : **클래스로부터 만들어진 객체**

인스턴스와 객체는 유사하지만 **객체가 조금 더 포괄적**인 의미  
- 객체는 모든 인스턴스를 대표  
- 인스턴스는 어떠한 클래스로부터 만들어진 것인지를 보다 강조

---------
객체의 구성요소
-----------
### 멤버 : **객체의 구성요소**인 속성(property), 기능(function)
이러한 멤버는 객체와 마찬가지로 **클래스에 정의**

다음은 속성, 기능과 동일한 용어이며, 주로 사용되는 용어는 각각 **멤버변수, 메서드**

     - 속성(Property) : 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)

     - 기능(function) : 메서드(method), 행위(behavior), 함수(function)

TV를 예로 들어 속성과 기능에 대해 자세히 알아보면

    TV의 속성 : 크기, 길이, 높이, 색상, 음량, 채널 등
    TV의 기능 : 켜기, 끄기, 볼륨 높이기, 채널 변경 등

                  채널 --> int channel
            채널 높이기 --> channelUp() {...}

위의 내용을 토대로 Tv클래스를 만들면

```java
class Tv {
    //Tv의 속성(멤버변수)
    String Color;
    boolean power; // on, off 두 가지 값이므로 boolean형
    int channel;


    void power() {     power = !power;} // TV의 전원 켜고 끔 (T-->F, F-->T)
    void channelUp(); {     ++channel;} // 채널 올림
    void channelDown(); {   --channel;} // 채널 내림
}
```

인스턴스의 생성과 사용
---------
클래스로부터 인스턴스를 생성하는 일반적인 방법은
```java
클래스명 참조변수명; // 클래스의 객체 참조를 위한 참조변수 선언
참조변수명 = new 클래스명(); // 클래스의 인스턴스 생성 후, 그 주소 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t 선언
t = new Tv(); // Tv인스턴스 생성 후, 인스턴스 주소 t에 저장
```
이 때 **인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치**해야 함.

다음은 앞서 만든 Tv클래스를 통해 인스턴스를 만들어 사용한 예제이다.

```java
class Tv {
    String Color;
    boolean power;
    int channel;


    void power() {     power = !power;}
    void channelUp(); {     ++channel;}
    void channelDown(); {   --channel;}
}

class TvTest {
    public static void main(String args[]) {
        Tv t;
        t = new TV();
        t.channel = 7; // Tv인스턴스의 멤버변수 channel 값을 7로 설정
        t.channelDown(); //Tv인스턴스의 메서드 channelDown()을 호출 --> --channel;로 channel값 1 감소
        System.out.println("현재 채널은 " + t.channel + " 입니다.");
    }
}
// 실행결과 : 현재 채널은 6입니다.
```
t.channel = 7; 처럼 인스턴스의 멤버변수에 접근할 때는 **`참조변수.멤버변수`** 형태로 사용

클래스의 또 다른 정의
---------

### - 객체지향이론의 관점에서 클래스 :  **객체를 생성하기 위한 틀**, **속성과 기능으로 정의**
### - 프로그래밍적 관점에서의 클래스 :

#### 1. 클래스 - 관련있는 데이터와 함수의 결합, 함께 정의한 것
    1. 변수 : 하나의 데이터를 저장하는 공간
    2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장하는 공간
    3. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장하는 공간
    4. 클래스 : 데이터와 함수의 결합(구조체 +  함수)

자바와 같은 객체지향언어에서는 서로 **관계있는 변수와 함수들을 함께 다룬다.**

#### 2. 클래스 - 사용자정의 타입(user-defined type)

- 자료형(primitive type) : 프로그래밍언어에서 기본적으로 제공
- 사용자정의 타입(user-defined type) :  **서로 관련된 변수들을 묶어서 하나의 타입으로 임의로 추가한 것**

예를 들어 3가지 시각을 다뤄야 할 때 배열을 통해 선언하면

```java
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];
```

시각을 구성하는 시, 분, 초가 서로 분리되어 있어 오류 발생가능!

시, 분, 초를 하나로 묶는 사용자정의 타입, 즉 클래스를 정의하면

```java
class Time {
int hour;
int minute;
float second;
}

...

Time[] t = new Time();
t[0] = new Time();
t[1] = new Time();
t[2] = new Time();

...
```
위간결하고 체계적으로 다룰 수 있음. 각 데이터의 추가조건(시간의 범위는 0~23 등)을 추가할 때도 객체지향언어에서는 제어자와 메서드를 이용해 쉽게 반영.

6.3 변수와 메서드
=======

선언위치에 따른 변수의 종류
------

**변수의 종류를 결정짓는 요소 : 변수의 선언된 위치**  
**멤버변수 제외한 나머지 변수는 지역변수**, **멤버변수 중 static 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스변수**

```java
class Variables
{
    int iv; // 인스턴스변수
    static int cv; // 클래스변수 (static변수, 공유변수)

    void method()
    {
        int lv = 0; // 지역변수 (메서드영역)
    }
}
```

 **iv, cv :  클래스 영역에 선언 --> 멤버변수**  
  **cv 앞 키워드 static --> 클래스변수**  
  **iv --> 인스턴스변수**

변수들의 선언위치와 생성시기를 정리하면

    * 인스턴스변수 : 클래스 영역에서 선언, 인스턴스가 생성될 때 같이 생성
    * 클래스변수 : 클래스 영역에서 선언, 클래스가 메모리에 올라갈 때 생성
    * 지역변수 : 클래스 이외의 영역에서 선언, 변수 선언문이 수행되었을 때 생성


> 이 때 클래스 이외의 영역에는 메서드, 생성자, 초기화 블럭 내부 등이 있다.

### 1. 인스턴스변수 (instance variable)
인스턴스변수는 **클래스 영역에서 선언되며, 클래스의 인스턴스를 생성할 때 만들어짐.**  
 **먼저 인스턴스를 생성해야** 인스턴스 변수 값 조작 가능  
 **독립적인 저장공간**을 가지므로 서로 다른 값을 가질 수 있음.  
 **인스턴스마다 고유한 상태를 유지**해야 할 때 선언

### 2. 클래스변수 (class variable)
**인스턴수변수 앞에 static**을 붙이면 클래스변수로 선언  
**인스턴스 생성 안해도 사용가능**  
**모든 인스턴스가 공통된 저장공간(변수) 공유**  
**한 클래스의 모든 인스턴스들이 공통적인 값을 유지**해야 할 때 선언  
 **`클래스이름.클래스변수`** 의 형식으로 사용

> ex) Variable 클래스의 클래스변수 cv를 사용하려면 Variable.cv

**클래스가 로딩될 때 생성되어 프로그램이 종료될 때까지 유지**되며, **public을 앞에 붙이면 전역변수**의 성격을 가짐.

### 3. 지역변수 (local variable)
메서드 내에서 선언되어 **메서드 내에서만 사용 가능**  
**메서드가 종료되면 소멸**  
마찬가지로 for문, while문 등의 **블럭 내에서 선언된 지역변수는 그 블럭 내에서만 사용**

> 메서드는 생성자와 초기화 블럭을 포함한다. 생성자와 초기화 블럭은 내부적으로 메서드로 취급된다.

클래스변수와 인스턴스변수
-----

카드를 클래스로 정의할 때 카드의 속성 : 무늬, 숫자, 폭, 높이  
카드의 개별적 속성 : 무늬, 숫자  
카드의 고유한 속성 : 폭, 높이

```java
class Card {
    String kind; // 카드의 무늬 : 인스턴스변수
    int number; // 카드의 변수 : 인스턴스변수
    static int width = 100; // 카드의 폭 : 클래스변수
    static int height = 250; // 카드의 높이 : 클래스변수
}
```
폭(width)과 높이(height)는 클래스변수로 선언 --> 한 카드의 해당 변수값만 바꿔도 모든 카드의 변수가 변경
> 클래스변수를 읽거나 변경할 때 '참조변수.클래스변수'로 사용할 수도 있지만 클래스변수와 인스턴스변수의 쉬운 구분을 위해 '클래스이름.클래스변수'의 형태로 사용하는 것이 바람직하다.

**인스턴스변수** : 인스턴스가 생성될 때마다 생성, **인스턴스마다 각기 다른 값**을 유지  
**클래스변수** :  인스턴스가 하나의 저장공간을 공유하므로, **항상 공통된 값**

메서드
-----
### **특정 작업을 수행하는 일련의 문장을 묶은 것** --> 함수와 유사
> 함수와 달리 메서드는 입력값 내지 출력값이 없을 수 있다.

### - 메서드의 장점
**1. 높은 재사용성**  
**2. 중복된 코드 제거**  
**3. 프로그램 구조화**



----------------------------------------------



3.4 메서드의 선언과 구현
========================
## 1) 메서드 선언부
>   ### (1) 메서드 선언부 = 메서드의 이름 + 매개변수 선언 + 변환 타입

> ###  (2) 메서드 선언부: 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는 지에 대한 정보 제공
## 2) 매개변수 선언
> ###  (1) 매개변수: 메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한것
## 3) 반환 타입 : 반환값이 없는 경우 void
## 4) 메서드의 구현부 = 메서드 몸통
## 5) return문 : return 문은 단 하나의 값만 반환 할 수있음
## 6) 지역변수 = 메서드 내에 선언된 변수

 
3.5 메서드의 호출 : 메서드를 호출해야만 구현부{}의 문장들의 수행됨
========================
## 1) 인자와 매개변수
> ###  (1) 인자 or 인수 = 메서드를 호출할 때 괄호 안에 지정해준 값

> ###  (2) 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야함

> ###  (3) 인자의 타입 : 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것
3.6 return문 = 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아감
========================
> ###  (1) 반환값 : return문의 반환값으로 주로 변수가 오긴 하지만 항상 그런것은 아님
> ### (수식일 경우-수식을 계산한 결과가 반환됨)
3.7 JVM의 메모리 구조
========================
## 정의
------------------------
>### 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는 데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리함
------------------------
## 구조
------------------------
 ## (1) 메서드 영역
 > ### 클래스파일 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장함

 ## (2) 힙
 > ### 인스턴스가 생성되는 공간
 ## (3) 호출스택
 > ### 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공함
 > ### 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용됨
 ------------------------
 ## 호출 스택 특징
 + 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다
 + 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다
 + 호출스택의 제일 위에있는 메서드가 현재 실행중인 메서드이다
 + 아래에 있는 메서드가 바로위의 메서드를 호출한 메서드이다


3.8 기본형 매개변수와 참조형 매개변수
========================
> ## (1) 기본형 매개변수 : 변수의 값을 일기만 할 수 있다(read only)
> ## (2) 참조형 매개변수
3.9 참조형 반환타입
========================
> ## 반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다
3.10 재귀호출
========================
> ## 매서드의 내부에서 매서드 자신을 다시 호출하는 것
> ## 재귀 메서드: 재귀호출을 하는 메서드
3.11 클래스 메서드와 인스턴스 메서드
========================
## (1) 클래스 메서드 = 메서드 앞에 static이 붙어있다
> ### 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는)메서드
## (2) 인스턴스 메서드 = 메서드 앞에 static이 붙어있지 않다
> ### 인스턴스 변수와 관련된 작업을하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드

> ### 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있는 것
--------------------
## 정리
--------------------
+ 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
+ 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다 (클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문)
+ 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다
+ 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다

3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출
========================
> ### 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능함. 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야함. 그 이유는 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문